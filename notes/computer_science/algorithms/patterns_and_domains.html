<!DOCTYPE DOCTYPE>

<html>
<head>
<meta charset="utf-8" content="text/html" http-equiv="Content-Type"/>
<!-- MATHJAX -->
<script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]},
            TeX: { equationNumbers: { autoNumber: "AMS" }}
        });
    </script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript">
</script>
<!-- CSS -->
<style type="text/css">
        body {
            width: 550px;
            margin-left: auto;
            margin-right: auto;
            font-size: 0.8em;
            font-family: Helvetica, Arial;
            text-align: justify;
            color: #222;
        }

        pre {
            width: 90%;
            margin-left: auto;
            margin-right: auto;
            padding-left: 7px;
            padding-right: 7px;
            padding-top: 5px;
            padding-bottom: 5px;
            border-radius: 2px;
            border: 1px solid #AAA;
        }

        h1, h2 {
            text-align: left;
        }

        h1 {
            font-size: 23px;

        }

        img {
            display: block;
            width: 90%;
            margin-left: auto;
            margin-right: auto;
            padding: 2px;
        }
    </style>
</head>
<body>
<h2>Patterns: A Communication Language</h2>
<p>In the late 1980s, a few visionary software developers began looking for new ways to communicate their designs with one another. Some of them happend upon a work by Christopher Alexander, a professor of architecture at the University of California, Berkeley, called A Pattern Language: Towns, Buildings, Construction (1977). In this seminal work, Alexander developed a theory for describing architectureal design. In 1987, Kent Beck and Ward Cunningham, two well-known leaders of teh object-oriented paradigm, introduced the idea of applying design paterns to programming at that year's Conference on Object Oriented Programming Systems, Languages and Applications (OOPSLA). The diea caight on and people began to think about software design patterns. In 1995, the seminal Gang of Four (GoF) book, Design Patterns: Elements of Reusable Object-Oriented Software (Gamma et al., 1995) was published, and a frenzy of research activity and application of appterns began.</p>
<p>As with any good idea, the software industry embraced patterns and their use became ubiquitous, to the point where everything could be described by a pattern. Using coding standards was pattern. Sitting together with a partner to debug a program was a pattern. Well, you get the idea. Patterns are a great way to communicate precisely and conisely well-formed concepts. We will -- at the risk of applying patterns to yet another area of computer science use patterns as a way to communicate the algorithms.</p>
<h2>Algorithm Pattern Format</h2>
<p>Each algorithm is presented using the following pattern sections:</p>
<ul>
<li>
<p><strong>Name</strong>: A descriptive name for the algorithm. This name is used to communicate concisely the algorithms to others. Name should always be in small caps.</p>
</li>
<li>
<p><strong>Synopsis</strong>:
    High level description of the algorithm and what it is design to do.</p>
</li>
<li>
<p><strong>Context</strong>:
    A description of a problem that illustrates the "sweet spot" for the algorithm.</p>
</li>
<li>
<p><strong>Forces</strong>:
    A description of the properties of the problem/solution that must be addressed and maintained for a succesful implementation. They are the things that would cause you to choose this algorithm specifically.</p>
</li>
<li>
<p><strong>Solution</strong>:
    The algorithm description using real working code with documentation. Where appropriate, UML class diagrams are also included.</p>
</li>
<li>
<p><strong>Consequences</strong>:
    Identifies and discusses the advantage/disadvantages and anti-patterns for this algorithm.</p>
</li>
<li>
<p><strong>Analysis</strong>:
    A synopsis of the analysis of the algorithm, including performance data as well as other data that helps the reader understand the behavior of the algorithm. Although the analysis section is not meant to "prove" the described performance of an algorithm, readers should be able to understand why the algorithm behaves as it does.</p>
</li>
<li>
<p><strong>Related Algorithms</strong>: 
    Presents either sligh variations of the algorithm or different alternatives.</p>
</li>
</ul>
<p>The real power of using such a template for the algorithms is that you can quickly compare and contrast different algorithms. At the same time, you can identify commonalities in seemingly different algorithms.</p>
<h2>Domains and Algorithms</h2>
<p>Domains became popular in the late 1980s when researchers began to explore how objecti-oriented principles could be used to promote software reuse. In the context of reuse, domains are application areas that share common traits. Each domain has its own vocabulary that provides a language to describe the domain. The language helps design systems and reusable components that are approprate for the particular domain. Domain-specific languages (DSLs) are used to model domains to generate domain-specific software, rather than construct it manually.</p>
<p>Algorithms, like applications, have domains. These domains are orthogonal to specific application domains. Algorithm domains provie us with knowledge about the application domains that are most amenable to certain types of algorithms. For example, if one is developing an aplication to access web services from a mobile phone, it would be appropriate to use algorithms optimized for space usage and external storage rather than simply the best overall time performance.</p>
<p>Algorithm domains are not as well defined as application domains; they are more general and span several application domains. Algorithm domains map more closely to standard computer science areas. We see, for example, search and graph traversal algorthms used frequently in aritifical intelligence applications, whereas numerical algorithms seldom appear in such applications. Database management system have their own set of algorithms that appear frequently, as do most other application domains.</p>
<p>In our algorhtm patterns we do not indicate any specific domain set for each algorithm, since no standard algorithm domain categorization exists. The context for each algorithm does, however, offer the reader a particular domain where the algorithm fits well. As one becomes familiar with algorithms and thinking of algorithms in terms of patterns, a natural taxonomy that maps application domains to algorithm domains emerges.</p>
<p>Developig the mapping between algorithm domains and application domains is an interesting and important research area. Obtaining an appropriate taxonomy will aid us to develop and generate better software components and applications. Researchers are applying advanced mathematical analysis to develop the categorizations (Algorithm Formalization, 2007).</p>
<p>From a practitioner's viewpoint, algorithm categorization comes from experiential tales, or war stories (Skiena, 1998). These informal anecdotes give the practitioner a more intuitive insight and confidence about when to use a praticular type of algorithm. The literature, both academic and industrial, is full of such war stories about algorithms, and we encourage you to develop your own. Such an exercise can help you internalize the algorithms and make you a better software developer. The beauty of algorithms is that the connection between algorithm domains and applicability is continually expanding. New algorithms are being developed, but possibly more importantly, new applications for existing algorithms are being discovered. Thinking of algorithms domains helps you manage this ever-complex relationship.</p>
</body>
</html>