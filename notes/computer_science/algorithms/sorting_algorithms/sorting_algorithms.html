<!DOCTYPE DOCTYPE>

<html>
<head>
<meta charset="utf-8" content="text/html" http-equiv="Content-Type"/>
<!-- MATHJAX -->
<script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]},
            TeX: { equationNumbers: { autoNumber: "AMS" }}
        });
    </script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript">
</script>
<!-- CSS -->
<style type="text/css">
        body {
            width: 550px;
            margin-left: auto;
            margin-right: auto;
            font-size: 0.8em;
            font-family: Helvetica, Arial;
            text-align: justify;
            color: #222;
        }

        pre {
            width: 90%;
            margin-left: auto;
            margin-right: auto;
            padding-left: 7px;
            padding-right: 7px;
            padding-top: 5px;
            padding-bottom: 5px;
            border-radius: 2px;
            border: 1px solid #AAA;
        }

        h1, h2 {
            text-align: left;
        }

        h1 {
            font-size: 23px;

        }

        img {
            display: block;
            width: 90%;
            margin-left: auto;
            margin-right: auto;
            padding: 2px;
        }
    </style>
</head>
<body>
<p>Numerous computations and tasks become simple by properly sorting information in advance. The search for efficient sorting algorithms dominated the early days of computing. Indeed, much of the early research in algorhtms focused on sorting collections fo data that were too large for the computers of the day to store in memory. Because computers are incredibly more powerful and faster than the computers of 50 years ago, the size of the data sets being processed is now on the order of terabytes of information. Although you may not be called upon to sort such huge data sets, you will likely need to sort perhaps tens or hundres of thousands of items.</p>
<h3>Terminology</h3>
<p>A collection of comparable elements $A$ is presented to be sorted; we use the notations <code>A[i]</code> and $a_i$ to refer to the i-th element of the collection. By convention, the first element in the collection is considered to be <code>A[0]</code>.</p>
<p>To sort a collection, the intent is to order the elements of <code>A</code> such that <code>A[i] &lt; A[j]</code>, then $i &lt; j$. If there are duplicate elements, then in the resulting ordered collection these elements must be contiguous; that is, there can be no $k$ such that $i &lt; k &lt; j$ and $A[i] \neq A[k]$.</p>
<h3>Comparable Elements</h3>
<p>The elemnts in the collection being compare must admit a total ordering. That is, for any two elements $p$ and $q$ in a colection, exactly one of the following three predicates is true:</p>
<ul>
<li>$p = q$</li>
<li>$p &lt; q$</li>
<li>$p &gt; q$</li>
</ul>
<p>Commonly sorted primitive types include integers, floatin-point values, and characters. When composite elements are sorted (such as strings of characters) then a lexicographical ordering is imposed on each individual element of hte composite, thus reducing a complex sort into individual sorts on primitive types. For example, the word "alphabet" is considered to be less than "alternate" but greater than "alligator" by comparing each individual letter, from left to right, until a word runs out of characters or an individual character in one word is less than or greater than its partner in the other word (thus "ant" is less than "anthem"). This question of ordering is far from simple when considering captilaization (is "A" greater than "a"?).</p>
<h3>Stable Sorting</h3>
<p>When a comparator function determines that two elements $a_i$ and $a_j$ in the original unordered collection are equal, it may be important to maintain their relative ordering in the sorted set; that is, if $i &lt; j$, then the final location for $a_i$ must be to the left of the final location for $a_j$. Sorting algorithms that guarantee this property are considered to be <strong>stable</strong>. An unstable algorithm pays no attention to the relationships between element locations in the original collection (it might maintain relative ordering, but it also might not).</p>
</body>
</html>