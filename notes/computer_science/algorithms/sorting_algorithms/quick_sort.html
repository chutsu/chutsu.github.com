<!DOCTYPE>
<html>
<head>
    <meta content="text/html" charset="UTF-8" http-equiv="Content-Type" />

    <!-- MATHJAX -->
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]},
            TeX: { equationNumbers: { autoNumber: "AMS" }}
        });
    </script>
    <script type="text/javascript"
        src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    </script>

    <!-- CSS -->
    <style type="text/css">
        body {
            width: 550px;
            margin-left: auto;
            margin-right: auto;
            font-size: 0.8em;
            font-family: Helvetica, Arial;
            text-align: justify;
            color: #222;
        }

        pre {
            width: 90%;
            margin-left: auto;
            margin-right: auto;
            padding-left: 7px;
            padding-right: 7px;
            padding-top: 5px;
            padding-bottom: 5px;
            border-radius: 2px;
            border: 1px solid #AAA;
        }

        h1, h2 {
            text-align: left;
        }

        h1 {
            font-size: 23px;

        }

        img {
            display: block;
            width: 90%;
            margin-left: auto;
            margin-right: auto;
            padding: 2px;
        }
    </style>
</head>
<body>
<h1>Quick Sort</h1>
<ul>
<li>Class: Sorting</li>
<li>Data Structure: Array</li>
<li>Worst case: $O(n^2)$</li>
<li>Best case: $O(n \log{n})$</li>
<li>Average case: $O(n \log{n})$</li>
</ul>
<p>The QUICK SORT algorithm, first introduced by C.A.R Hoare, is simpler than the MEDIAN SORT, since it uses many of the same concepts, but instead of seeking the median value, QUICK SORT selects an element according to some strategy (sometimes randomly, sometimes the leftmost, sometimes the middle one) to partition an array into subarrays. Thus QUICK SORT has two steps. The array is partitioned around a <code>pivot</code> value, creating a left subarray that contains elements less than or equal to the <code>pivot</code>, and a right subarray that contains elements greater than or equal to the <code>pivot</code>. Each of these subarays is then recursively sorted.</p>
<h2>Pseudo Code</h2>
<pre><code>SORT(A)

    QUICK-SORT(A, 0, n - 1)


QUICK-SORT(A, left, right)

    if (left &lt; right)
        pi = partition(A, left, right)
        QUICK-SORT(A, left, pi - 1)
        QUICK-SORT(A, pi + 1, right)


PARTITION(A, left, right)

    p = select pivot in A[left, right]
    swap A[p] and A[right]
    store = left

    for i = left to right - 1
        if (A[i] &lt;= A[right])
            swap(A[i], A[store])
            store++
    swap(A[store], A[right])

    return store
</code></pre>
<p>The random nature of the algorithm makes it a challenge to prove that the avergage-case performance is $O(n \log n)$. QUICK SORT exhibits worst-case quadratic behaviour if the partiioning at each recursive step only divides a collection of $n$ elements into an "empty" and "large" set, where one of these sets has no elelments and the other has $n - 1$ (note that the pivot element provides the last of the $n$ elements, so no element is lost).</p>
<p>The choice of <code>pivot</code> strongly influences the relative sizes of the two subarrays after the execution of partition. Instead of jusing choosing pivot to be a random element, one can choose it to be the <strong>median</strong>  of $k$ random elements for some odd $k$.</p>
<h2>Consequences</h2>
<p>Surprisingly, the random algorithm for selecting a pivot enables QUICK SORT to provide an average-case performance that usually outperforms other sorting algorithms. In addition, there are numerous enahncements and optimizations researched for QUICK SORT that have wrought the most efficency out of any sorting algorithm.</p>
</body>
</html>